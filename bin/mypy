#!/usr/bin/env python

# Operate on text files.

import cPickle
from numpy import *
import numpy as np
import os
import sys

class CircularDependency(Exception):
  pass

class NamespaceWrapper(dict):
  """A wrapper for the locals() dictionary.

  The logic that is added includes:
    - rewrite variable name "o" to "result"
    - process variable names "lines", "table", and "num_table" as calls to
    lines(), table(), and num_table(), respectively.
    - rewrite "result" (or "o") as an RVALUE to "table" when the
      variable is empty.
    - process variable name "num_words" as call to map(float, words)
  """

  #: Variables that will be rewritten as other variables.
  var_rules = {}

  #: Variables that will be rewritten as calls to functions.
  func_rules = {}

  def __init__(self, vs, var_rules = None, func_rules = None):
    #: Set of local variables.
    self.vs = vs
    if var_rules:
      self.var_rules = var_rules
    if func_rules:
      self.func_rules = func_rules

  def _lookup(self, item):
    """Dealias a symbol name."""
    stack = set()
    while item in self.var_rules:
      if item in stack:
        raise CircularDependency
      stack.add(item)
      item = self.var_rules[item]
    return item

  def get(self, item, default = None):
    """Lookup an item from the dictionary.

    Apply variable rewrites before function rewrites.

    """
    try:
      return self[item]
    except KeyError:
      return default

  def __getitem__(self, item):
    item = self._lookup(item)
    if item in self.func_rules:
      # Replace an RVALUE symbol with the results of a function call.
      func = self.func_rules[item]
      result = func()
    else:
      # Try to resolve the symbol in the local namespace. If this fails, it will
      # cause the evaluator to look for the symbol in the global namespace instead.
      result = self.vs[item]
    return result

  def __contains__(self, item):
    item = self._lookup(item)
    return (item in self.vs)

  def __setitem__(self, item, value):
    item = self._lookup(item)
    self.vs[item] = value

  def VarRule(self, **kwargs):
    """Add a rule to alias two variable names."""
    for k, v in kwargs.items():
      if not isinstance(v, basestring):
        raise ValueError("Rewrite value must be a string, but got: %s" % (v,))
      self.var_rules[k] = v

  def FuncRule(self, **kwargs):
    """Add a rule to alias a variable name with a function call."""
    for k, v in kwargs.items():
      if not hasattr(v, '__call__'):
        raise ValueError("Rewrite value must be a function, but got: %s" % (v,))
      self.func_rules[k] = v

class HelpfulNamespaceWrapper(NamespaceWrapper):

  def GetSymbols(self):
    symbols = dict()
    for k, v in self.var_rules.items():
      symbols[k] = "alias for %s" % v
    for k, v in self.func_rules.items():
      symbols[k] = v.__doc__
    return symbols

def read_lines(path):
  if isinstance(path, basestring):
    fh = open(path)
  else:
    fh = path
  result = list( _.strip() for _ in fh.readlines() )
  if fh != path:
    fh.close()
  return result

def read_table(path, delim = " "):
  """read contents of file as a table"""
  result = [ _.split(delim) for _ in read_lines(path) ]
  return result

def read_num_table(path, delim = " "):
  """read contents of file as a table"""
  result = np.array([ map(float, line) for line in read_table(path, delim) ])
  return result

def toline(xs):
  """Format a list as a string with one line."""
  return " ".join(map(str, xs)) if hasattr(xs, '__iter__') else str(xs)

def tolines(xss):
  """Format a 2D list as a string with multiple lines."""
  return "\n".join(map(toline, xss)) if hasattr(xss, '__iter__') else str(xss)

class FileNamespace(HelpfulNamespaceWrapper):

  # Caches for whole-input function calls.
  _lines = None
  _table = None
  _num_table = None

  def __init__(self, vs, fh = sys.stdin, word_delimiter = " ", numeric = False):
    super(FileNamespace, self).__init__(vs,
        var_rules = dict(o = "output", result = "output", t = "table"),
        func_rules = dict(table = self.table, lines = self.lines,
            num_table = self.num_table,
#            output = self.get_output
            ))
    self.fh = fh
    self.word_delimiter = word_delimiter
    if numeric:
      self.VarRule(table = "num_table")

  def lines(self):
    """input as a list of lines"""
    if self._lines == None:
      #~ self._lines = list( _.strip() for _ in self.fh.readlines() )
      self._lines = read_lines(self.fh)
    return self._lines

  def table(self):
    """input as a 2D list of words"""
    if self._table == None:
      #~ self._table = [ _.split(self.word_delimiter) for _ in self.lines() ]
      self._table = read_table(self.fh, self.word_delimiter)
    return self._table

  def num_table(self):
    """input as a 2D array of floats"""
    if self._num_table == None:
      #~ self._num_table = np.array([ map(float, _.split(self.word_delimiter)) for _ in self.lines() ])
      self._num_table = read_num_table(self.fh, self.word_delimiter)
    return self._num_table

  def get_output(self):
    """Get the current output buffer, using the input buffer if the output is undefined."""
    output = self.vs["output"]
#    if output == None:
#      output = self["table"]
#      self.vs["output"] = output
    return output

class LineNamespace(HelpfulNamespaceWrapper):

  def __init__(self, vs, numeric = False):
    super(LineNamespace, self).__init__(vs,
        var_rules = dict(o = "output", result = "output", w = "words", l = "line", n = "num"),
        func_rules = dict(num_words = self.num_words,
#            output = self.get_output
        ))
    if numeric:
      self.VarRule(words = "num_words")

  def num_words(self):
    """current line as a 1D numpy array of floats"""
    return np.array(map(float, self.vs["words"]))

  def get_output(self):
    """Get the current output buffer, using the input buffer if the output is undefined."""
    output = self.vs["output"]
#    if output == None:
#      output = self["line"]
#      self.vs["output"] = output
    return output

def pickle(obj, path = None):
  if path == None:
    fh = sys.stdout
  else:
    fh = open(path, 'w')
  cPickle.dump(obj, fh, protocol = 2)
  if fh != sys.stdout:
    fh.close()

def unpickle(path = None):
  if path == None:
    fh = sys.stdin
  else:
    fh = open(path, 'r')
  result = cPickle.load(fh)
  if fh != sys.stdin:
    fh.close()
  return result

def InitPlotting():
  # If the DISPLAY environment variable is set, then assume the plot can be displayed on screen.
  use_file_output = ('DISPLAY' not in os.environ)
  import matplotlib
  if use_file_output:
    matplotlib.use("cairo")
  elif matplotlib.get_backend() == "":
    matplotlib.use('TkAgg')
  # XXX Make symbols available via globals.
  global mpl, plt, plot
  import matplotlib as mpl, matplotlib.pyplot as plt
  plot = plt.plot

class Processor(object):

  word_delimiter = " "
  iterate_lines = False
  numeric = False
  output_file = None
  plotting = False
  quiet = False
  raw_output = False
  statement = False
  fhin = sys.stdin
  fhout = sys.stdout
  verbose = False

  def Log(self, msg):
    if self.verbose:
      print >>sys.stderr, msg

  def Evaluate(self, cmd, vs, codeobj = None):
    """Evaluate (or execute) a command on the input file."""

    def format_exception():
      lines = cmd.split("\n")
      lines = [ "%s" % _[:100] for _ in lines ]  # truncate long lines
      # Get stack trace
      etype, e, tb = sys.exc_info()
      import traceback
      tb_entries = traceback.extract_tb(tb)[1:]
      offset = None
      lineno = None
      # Determine line and column for error
      script_frames = [ ent for ent in tb_entries if ent[0] == "<string>" ]
      if script_frames:
        lineno = script_frames[-1][1]
      if isinstance(e, SyntaxError):
        offset = e.offset
        msg = "Syntax error"
      else:
        msg = "%s: %s" % (etype.__name__, str(e))
      print >>sys.stderr, "ERROR in script:"
      # Print traceback
      for ent in tb_entries:
        fn, ln, cn = ent[:3]
        print >>sys.stderr, "  From %s, line %d%s" % \
            ("script" if fn == "<string>"
            else fn, ln, ", function %s" % cn if cn != "<module>" else "")
      print >>sys.stderr, "  %s" % msg
      # Print original script, indicating location of error
      print >>sys.stderr, "Source:"
      numbered_lines = [ ("[%3d] %s" % (idx+1, line))
          for (idx, line) in enumerate(lines) ]  # number lines
      if lineno != None:
        # If no column is given, use offset of first non-whitespace character
        if offset == None:
          line = lines[lineno]
          offset = len(line) - len(line.lstrip())
        numbered_lines.insert(lineno, "%s^" % (" " * (6 + offset)))
      print >>sys.stderr, "\n".join(numbered_lines)
      sys.exit(-1)

    if cmd == None:
      raise ValueError("Command must not be empty")
    if codeobj == None:
      codeobj = cmd
    if self.statement:
      self.Log("Evaluated statement:\n  %s" % cmd)
      try:
        exec codeobj in globals(), vs
      except:
        format_exception()
      if 'result' not in vs:
        self.Log("Warning: result is not set")
      result = vs.get('output', None)
    else:
      self.Log("Evaluated expression:\n  %s" % cmd)
      try:
        result = eval(codeobj, globals(), vs)
      except:
        format_exception()
    return result

  def PrintResult(self, result, as_line = False):
    if self.plotting:
      import matplotlib.pyplot as plt
      if self.output_file:
        plt.savefig(self.output_file)
      else:
        plt.show()
    if self.quiet:
      return
    if self.raw_output:
      print result
    elif not (result is None or result is False):
      if as_line:
        result = toline(result)
      else:
        result = tolines(result)
      self.fhout.write(result)
      if not result.endswith('\n'):
        self.fhout.write('\n')

  def ProcessByLine(self, cmd):
    """Evaluate a command once per line of the input file."""
    line = None
    num = None
    words = None
    if self.plotting:
      InitPlotting()
    if not cmd:
      cmd = "line"
    elif cmd == "help":
      _vars = LineNamespace(locals(), numeric = self.numeric)
      symbols = _vars.GetSymbols()
      symbols.update(
          line = "current input line as a single string",
          num = "current line number",
          words = "current input as a list",
          output = "value to print")
      Help(symbols = symbols)
    codeobj = compile(cmd, 'command', 'single' if self.statement else 'eval')
    for numz, line in enumerate(self.fhin):
      line = line[:-1]
      n = num = numz + 1
      words = [w for w in line.strip().split(' ') if len(w)]
      _vars = LineNamespace(locals(), numeric = self.numeric)
      result = self.Evaluate(cmd, _vars, codeobj = codeobj)
      self.PrintResult(result, as_line = True)

  def ProcessAtOnce(self, cmd):
    """Evaluate a command once for the entire input file."""
    result = None  # define here, in case "exec cmd" forgets to assign
    p = self
    if self.plotting:
      InitPlotting()
    _vars = FileNamespace(locals(), fh = self.fhin,
        word_delimiter = self.word_delimiter, numeric = self.numeric)
    if not cmd:
      cmd = "lines"
    elif cmd == "help":
      symbols = _vars.GetSymbols()
      symbols.update(output = "value to print")
      Help(symbols = symbols)
    result = self.Evaluate(cmd, _vars)
    self.PrintResult(result)

  def Process(self, cmd):
    """Evaluate a command on the input file."""
    if self.iterate_lines:
      self.ProcessByLine(cmd)
    else:
      self.ProcessAtOnce(cmd)

def Help(msg = None, symbols = None):
  print >>sys.stderr, "usage: %s [OPTIONS] CMD INPUT" % sys.argv[0]
  print >>sys.stderr, """where OPTIONS is one of:
  -d DEL           Use DEL as the delimiter between columns of input data
  -e               Evaluate CMD for each line of input, rather than the entire file
  -h, --help       Print this help and exit
      --help-cmds  Print information about available commands and exit
  -m MOD           Import MOD before running commands
  -n               Treat all input values as numeric
  -o FILE          Save the results to FILE (if -p, save the plot instead)
  -p               Use plotting commands (implies -q)
  -q               Do not print result (be quiet)
  -r               Print raw output
  -s               Treat CMD as a statement
  -v               Be verbose"""
  if symbols:
    print >>sys.stderr, "CMD can contain any of the following symbols:"
    keys = symbols.keys()
    nonalias_keys = [ k for k in keys if not symbols[k].startswith("alias") ]
    if nonalias_keys:
      max_length = max(map(len, nonalias_keys))
      for k in sorted(nonalias_keys):
        pad = " " * (2 + (max_length - len(k)))
        print >>sys.stderr, "%s%s -- %s" % (pad, k, symbols[k])
    alias_keys = [ k for k in keys if symbols[k].startswith("alias") ]
    if alias_keys:
      max_length = max(map(len, alias_keys))
      for k in sorted(alias_keys):
        pad = " " * (2 + (max_length - len(k)))
        print >>sys.stderr, "%s%s -- %s" % (pad, k, symbols[k])
  if msg:
    print >>sys.stderr, msg
  sys.exit(-1)

def main():
  import getopt
  p = Processor()
  try:
    opts, args = getopt.getopt(sys.argv[1:], 'd:ehm:no:pqrsv', ['help', 'help-cmds'])
  except getopt.GetoptError, e:
    Help("ERROR: %s" % (e,))
  if len(args) > 0:
    cmd = args[0].rstrip()
  else:
    cmd = ""
  if len(args) > 1:
    p.fhin = open(args[1])
  for opt, arg in opts:
    if opt == '-d':
      p.word_delimiter = arg
    elif opt == '-e':
      p.iterate_lines = True
    elif opt in ('-h', '--help'):
      Help()
    elif opt == '--help-cmds':
      cmd = "help"  # override command, causing namespace-specific help to be printed
    elif opt == '-m':
      # Import requested modules
      globals()[arg] = __import__(arg.strip())
    elif opt == '-n':
      p.numeric = True
    elif opt == '-o':
      p.output_file = arg
    elif opt == '-p':
      p.plotting = True
      p.quiet = True
    elif opt == '-q':
      p.quiet = True
    elif opt == '-r':
      p.raw_output = True
    elif opt == '-s':
      p.statement = True
    elif opt == '-v':
      p.verbose = True
  try:
    p.Process(cmd)
  except KeyboardInterrupt:
    pass

if __name__ == '__main__':
  main()
